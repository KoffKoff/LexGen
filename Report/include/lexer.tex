\chapter{Lexer}
\#Some Text describing what the report will illuminate in this chapter.
\section{Lexer}
A Lexer, lexical analyzer, is a program which jobb is to convert a string of a
formal language into a sequence of tokens. \#Hitta REF.
This can be done by using regular expressions, regular sets and finite
automata. Which are centerel consepts in formal language theory. \cite{Aho} 
\subsection{Languages}
\subsubsection{Formal Languages}
\subsubsection{Regular Languages}
Like any formal language, a regular language is a set of strings. In other words a sequence of symbols,
from a finite set of symbols. Only some formal languages are regular; in fact, 
regular languages are exactly those that can be defined by regulat expressions.
\cite{Ranta2012}
\subsection{Regular Expressions}
Regular expressions are used to describe a patterns in a string.
In a regular language, a programming language, this is usefull.
Since these languages are build on very strict rules on how strings
must follow a pattern. \#Ref p√• detta!! 

\begin{definition}[Regular Expressions \cite{Aho}]
\begin{enumerate}
  \item The following characters are meta characters $\{ '|', '(', ')', '*' \}$.
  \item A none meta character $a$ is a regular expression that matches the 
      string $a$.
  \item If $r_1$ and $r_2$ are regular expressions then $(r_1 | r_2)$ is a 
      regular expression that matches any string that matches $r_1$ or $r_2$.
  \item If $r_1$ and $r_2$ are regular expressions. $(r_1)(r_2)$ is a regular
      expression of the form that matches the string $xy$ iff $x$ matches $r_1$
      and $y$ matches $r_2$.
  \item If $r$ is a regular expression the $r*$ is a regular expression that
      matches any string of the form $x_1, x_2, \dots , x_n, n \geq 0$.
      Where $r$ matches $x_i$ for $1 \leq i \leq n$, in particular $(r)*$ 
      matches the empty string, $\varepsilon$.
  \item If $r$ is a regular expression, then $(r)$ is a regular expression that
      matches the same string as $r$.
\end{enumerate}
\end{definition}
Many parantheses can be reduced by adopting the convention that the Kleene
closure operator $*$ has the highest precedence, then concat and then or
operator $|$. The two binary operators, cancat and $|$ are left 
left-associative. \cite{Aho}
\subsection{Finite State Machine}
\subsection{Known Solutions}
\section{FingerTree}
\section{BNF}
\section{Yi}
\section{Haskell}
\section{Monoid (data type)}

 
