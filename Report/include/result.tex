\chapter{Result}
The incremental lexer has as mentioned before three requirements, it should be
Robust, Efficient and Precise. Robustness means that the lexer does not crash
when it encounter an error in the syntax. That is, if a string would yield an
error when lexed from the starting state the lexer does not return that error but
instead stores the error and lexes the rest of the possible input states since
the current string might not be at the start of the code.

For it to be efficient
the feedback to the user must be instant, or more formally the combination of two
strings should be handled in $O(log(n))$ time.

Finally to be precise the lexer
must give a correct result. This chapter will talk about how these requirements
are tested and what the results were.

In the sections Below, any mention of a sequential lexer refers to a lexer
generated by Alex using the same alex file as was used when creating the
incremental lexer \cite{alex}. The reason why Alex was used is because the DFA
generated by Alex was used in the incremental lexer, thus ensuring that only the
lexical routines differs.
%\section{Robustness}

\section{Preciseness}
For an incremental lexer to work, the lexer must be able to do lexical analysis
of any sub text of a text and be able to combine two sub texts. If the lexical
analysis of one sub text does not result in any legal tokens it must be able to be
combined with other sub texts that makes it legal tokens. The lexical analysis of
a sub text might not always result in the same tokens that the combination of the
sub text with another text would give.

To test these cases a test was constructed that does a lexical analysis on two
sub texts using the incremental lexer and then combining the results into one
text. The result of the combination should be the same as the lexical analysis
of the text using the incremental lexer and the result using a sequential lexer.

It is not enough to test if the combination of two sub texts yields the
same sequence of tokens as the text. To test that the result of the
incremental lexer is the correct sequence of tokens generated, it is compared to
what a sequential lexer generates. This comparison is an equality test of
the text, it checks token for token that they are the same kind of token and
have the same lexeme.
\cref{fig:CheckEquility} shows the test for equality:
\begin{figure}[h!]
  \centering
  \lstinputlisting[language=c]{examples/CorrectEquility.hs}
  notEqual function is a function which pattern-match on the two different
  tokens and returns true if they are not of the same type.
  \caption{Code for testing tokens from IncLex is equal to tokens from Alex. 
  \label{fig:CheckEquility}}
\end{figure} 

%\section{Efficiency}
\section{Performance}
To measure the performance of the incremental step we created the fingertree for
two pieces of code. By creating the two fingertrees the transition map for the
code in those trees are created as well. The benchmarking was then done on the
combination of the two trees. The results of the incremental lexer benchmarking
suggests a running time of $O(log(n))$. To get a reference point the same text
was lexed using a sequential lexer. The benchmarks can be found in
\cref{fig:IncSeqTime} and \cref{fig:IncTime}.

%Tester för nybyggning av träd?
\begin{figure}[!htp]
%\begin{center}
\begin{tikzpicture}
    \begin{axis}[
    width=0.7\textwidth,
    height=0.4\textwidth,
    ymajorgrids,
    xmajorgrids,
    title = {Incremental lexer},
    scaled y ticks=real:1,
    scaled x ticks=real:1e3,
    ymin=0,
    xmin=0,
%    x tick label style={/pgf/number format/1000 sep=},
    ytick scale label code/.code={},
    xtick scale label code/.code={},
    ylabel={$\mu s$},
    xlabel={$*1000$ characters},
    legend pos=outer north east
    ]
        \addplot table[x=n,y=upd] {time.csv};\addlegendentry{Incremental update}
    \end{axis}
\end{tikzpicture}
%\end{center}
\caption{Benchmarking times of the incremental lexer\label{fig:IncTime}}
\end{figure}
\begin{figure}[!htp]
%\begin{center}
\begin{tikzpicture}
    \begin{axis}[
    width=0.7\textwidth,
    height=0.4\textwidth,
    ymajorgrids,
    xmajorgrids,
    title = {Comparison},
    scaled y ticks=real:1e3,
    scaled x ticks=real:1e3,
    ymin=0,
    xmin=0,
%    x tick label style={/pgf/number format/1000 sep=},
    ytick scale label code/.code={},
    xtick scale label code/.code={},
    ylabel={$ms$},
    xlabel={$*1000$ characters},
    legend pos=outer north east
    ]
        \addplot table[x=n,y=upd] {time.csv};\addlegendentry{Incremental update}
        \addplot table[x=n,y=alex] {time.csv};\addlegendentry{Sequential lexing}
    \end{axis}
\end{tikzpicture}
%\end{center}
\caption{Comparison between the incremental and sequential lexer\label{fig:IncSeqTime}}
\end{figure}

Since the incremental lexer uses a tree structure there will be an increase in
data-space used compared to a sequential lexer. Since the root of every subtree
stores the completed tokens for that tree, every level of the tree will store
aproximatly the size of the complete tokens for the entire text. A lexer that
uses a DFA with $m$ states will produce token data structure that grows with
$\theta(mn)$ since each in state will have the tokens for that state. The depth
of the tree is $\log(n)$, this suggest a space complexity of
$\theta(mn\log(n))$.

To test the space complexity we used a DFA for an early java version that has
90 states. To see how much the data structure grows the transition map was
serialized and stored to the disc using the haskell library $Data.Binary$. The
test suggests that the size of the transition map grows linearly with the size
of text being lexed, the results can be found in \cref{fig:IncSpace}.

\begin{figure}[!htp]
%\begin{center}
\begin{tikzpicture}
    \begin{axis}[
    width=0.7\textwidth,
    height=0.4\textwidth,
    ymajorgrids,
    xmajorgrids,
    title = {Space for transition map},
    ymode = log,
    xmode = log,
%    scaled y ticks=real:1,
%    scaled x ticks=real:1,
    x tick label style={/pgf/number format/1000 sep=},
%    ytick scale label code/.code={Bytes},
%    xtick scale label code/.code={Characters},
    ylabel={KB},
    xlabel={Characters},
    legend pos=outer north east
    ]
        \addplot table[x=n,y=size] {space.csv};\addlegendentry{Incremental update}
    \end{axis}
\end{tikzpicture}
%\end{center}
\caption{Space usage of the transition map using a DFA with 90 states\label{fig:IncSpace}}
\end{figure}

\begin{filecontents*}{time.csv}
%characters*1000, time in microsecs
n      alex   upd
1000   210    150
10000  1901   251
20000  3910   329
30000  5303   361
40000  7079   361
50000  8933   367
60000  12140  460
70000  14860  469
80000  16850  523
90000  17170  424
100000 20920  554
110000 24960  486
120000 26430  503
130000 28420  649
140000 37890  575
150000 33790  570
160000 36850  624
170000 39860  468
180000 42570  496
190000 42410  513
\end{filecontents*}

\begin{filecontents*}{space.csv}
n       size
100     11
200     21
400     40
800     77
1600    259
3200    387
6400    643
12800   1283
25600   2436
51200   4870
102400  9737
204800  19346
409600  38688
819200  77244
1638400 154486
\end{filecontents*}
