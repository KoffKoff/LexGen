\chapter{Result}
The incremental lexer has as mentioned before three requirements, it should be
Robust, Efficient and Precise. Robustness means that the lexer doesn't crash
when it encounter an error in the syntax. That is, if a string would yield an
error when lexed from the starting state the lexer doesn't return that error but
instead stores the error and lexes the rest of the possible input states since
the current string might not be at the start of the code. For it to be efficient
the feedback to the user must be instant, or more formaly the combination of two
string should be handled in $O(log(n))$ time. Finally to be precise the lexer
must give a correct result. This chapter will talk about how these requirements
are tested and what results the from the tests were.

In the sections Below, any mention of a sequential lexer refers to a lexer
generated by Alex using the same alex file as was used when creating the
incremental lexer \cite{alex}. The reason why Alex was used is because the dfa
generated by Alex was used in the incremental lexer, thus ensuring that only the
lexical routines differs.
%\section{Robustness}

\section{Preciseness}
For an incremental lexer to work, the lexer must be able to do lexical analysis
of any subsection of a text. That is, come to a correct result for that subsection
for every possible instate. It must also be able to merge any two neighboring
subsections in a text. The result of that merge must be the same as lexing
the two subsections as one section.

It is not enough to test if the combination of two subsections yields the
same sequence of tokens as the section. To test that the result of the
incremental lexer is the correct sequence of tokens generated, it is compared to
what a sequential lexer generates. This comparison is an equality test of
the text, it checks token for token that they are the same kind of token and
have the same lexeme.
\cref{fig:CheckEquility} shows the test for equality:
\begin{figure}[h!]
  \centering
  \lstinputlisting[language=c]{examples/CorrectEquility.hs}
  notEqual function is a function which pattern-match on the two different
  tokens and returns true if they are not of the same type.
  \caption{Code for testing tokens from IncLex is equal to tokens from Alex. 
  \label{fig:CheckEquility}}
\end{figure} 

%\section{Efficiency}
\section{Performance}
To measure the perfomance of the incremental step we created the fingertree for
two pieces of code. By creating the two fingertrees the transition map for the
code in those trees are created aswell. The benchmarking was then done on the
combination of the two trees. The results of the incremental lexer benchmarking
suggest running time of $O(log(n))$.

To get a reference point the same text was lexed using a sequential lexer.

\#Lägga till nåt om minnes utrymmet som krävs.

\#Bättre förklaring till graferna.

\#Tester för nybyggning av träd?

\begin{filecontents*}{data.csv}
%characters*1000, time in microsecs
n    alex   upd
1    210    150
10   1901   251
20   3910   329
30   5303   361
40   7079   361
50   8933   367
60   12140  460
70   14860  469
80   16850  523
90   17170  424
100  20920  554
110  24960  486
120  26430  503
130  28420  649
140  37890  575
150  33790  570
160  36850  624
170  39860  468
180  42570  496
190  42410  513
\end{filecontents*}
%\begin{example}[Benchmarking times of the incremental and sequential lexer]\label{bench}
\begin{tikzpicture}
    \begin{axis}[
    width=0.9\textwidth,
    height=0.4\textwidth,
    ymajorgrids,
    title = {Comparison},
    x tick label style={/pgf/number format/1000 sep=},
    ytick scale label code/.code={ms},
    legend pos=outer north east
    ]
        \addplot table[x=n,y=alex] {data.csv};\addlegendentry{Sequential}
        \addplot table[x=n,y=upd] {data.csv};\addlegendentry{Incremental update}
    \end{axis}
\end{tikzpicture}\\
\begin{tikzpicture}
    \begin{axis}[
    width=0.9\textwidth,
    height=0.4\textwidth,
    ymajorgrids,
    title = {Incremental lexer},
    x tick label style={/pgf/number format/1000 sep=},
    ytick scale label code/.code={$\micro s$},
    legend pos=outer north east
    ]
        \addplot table[x=n,y=upd] {data.csv};\addlegendentry{Incremental update}
    \end{axis}
\end{tikzpicture}\\
%\end{example}
